# Session 7: Designing Projects for the Classroom

Lesson Plan for JavaScript Professional Development

##### Outline

- Morning Lesson
  - Introduction (10 min)
  - Final Team Project
  - Wrap-up (10 min)
- Afternoon Project

## Morning Lesson

Total time: ~2.5 hours

In pairs, work through the [mysounds](mysounds/) tutorial.

After each step, share solutions as a group.

## Afternoon Workshop

### Web Programming Project Design

Stages of designing a classroom project for learning web programming.

#### The Standard Entry Points

- Define learning outcomes
- Choose assessment methods
- Confirm that a project is the best format
  - Would exercises or a lab be better?

#### Picking Relevant Projects

- Brainstorm project options
  - Games
    - Most real-world games can usually be translated into an interactive web page
    - Pros: great for engagement and interaction; rules/systems are clearly defined
    - Cons: often have complex UI, which can be a bottleneck
    - Examples:
      - Number/word guessing games (e.g. Jeopardy, Hangman)
      - Card games (e.g. Blackjack, Go Fish, Set)
      - Board games (e.g. Mancala, Go, Chess)
      - Video games (best using a framework like Phaser)
  - Software Clones
    - When in doubt, just "clone" an existing application
    - Pros: clearly relevant and world-tested; "real" version is readily available for comparison
    - Cons: often hard to break down into manageable chunks for beginners without losing too many key features; can be less inspiring
    - Examples:
      - Mini Twitter
      - Mini Facebook
      - Mini Tumblr
  - School Services
    - Projects that could (in theory) be used in/by the school
    - Pros: students and teachers can be the users (always better to solve problems close to home)
    - Cons: can feel contrived
    - Examples:
      - Portfolio of student art
      - Homework management to-do list
      - Classroom chat
      - Sports team scoreboard
      - Calendar of events
      - Class bulletin board
      - Attendance taking
- Pick one using criteria of:
  - Interesting/meaningful to students
  - Can be completed using the goal knowledge, and doesn't require more
  - Adequately utilizes and engages the key concepts
  - Is appropriately scoped to the time available
  - Has clear stages of development

#### Make Finish and Start Points

- What are the completion options?
  - What constitutes a minimal completion?
  - Which differentiated outcomes can be used?
    - Remember to stay w/in topic
- What are the start conditions?
  - Scaffolding: provide enough code to get students started and gaining momentum from step 1
  - Ensure that students spend time understanding context
  - Give them an immediate and simple way to verify/test their code
    - Need to establish feedback loops
- What are the specs for the final project?
  - Expressed as: tests, plain specs, user stories, an example solution (i.e. an animated GIF or video showing the user interface in action)

#### Break Down the Work

- What is the progression style:
  - Additive: each step builds off of the last one, producing ever-better products. (Easiest to design)
  - Subtractive: give them a bunch of bad code, tell them to refactor and/or debug the code. (Most up-front work to design)
  - Organic: each step produces a functional product, but may involve removing/editing earlier code. (Most complex progression, also most realistic to problem-solving patterns)
- What are the various steps?
  - Some other names for them: versions, objectives, stories, epics
  - Based on progression style, find natural fission points in the project
- What additional steps are available for advanced students?

#### Validate Against Goals

- Does the design build towards the outcomes effectively?
- Is the "minimal completion" enough to hit the key learning outcomes?
- Are the steps spaced well to keep students engaged and motivated?
- Is enough auxiliary material supplied for students to find what they need to succeed?
